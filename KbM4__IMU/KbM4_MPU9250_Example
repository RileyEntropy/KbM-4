#include <MPU9250.h>         // For MPU9250 sensor
#include <HID-Project.h>      // HID Project library for USB mouse/keyboard support on Pro Micro
#include <Wire.h>
#include <math.h>             // For mathematical functions like fabsf()

// MPU9250 object
MPU9250 mpu;

// Betaflight "Actual" rates parameters
#define RC_RATE_X 1.0f  // Range: 0.01-2.55
#define RC_RATE_Y 1.0f  // Range: 0.01-2.55
#define RATE_X 0.8f     // Range: 0.0-1.0
#define RATE_Y 0.8f     // Range: 0.0-1.0
#define EXPO_X 0.2f     // Range: 0.0-1.0
#define EXPO_Y 0.2f     // Range: 0.0-1.0

// Other customizable parameters
#define MAX_DELTA 1000.0f
#define UPDATE_INTERVAL 1
#define SMOOTHING_FACTOR 0.7f
#define DRIFT_THRESHOLD 0.1f

float baselineX, baselineY;
float smoothedDeltaX = 0, smoothedDeltaY = 0;

// Betaflight "Actual" rates function
float applyBetaflightActualRates(float rcCommand, float rcRate, float rate, float expo) {
    float stickMovement = rcCommand;
    float breakpoint = 1.0f / rate;

    // Normalize the stick movement based on the breakpoint
    if (rcCommand != 0) {
        if (rcCommand > 0) {
            if (rcCommand >= breakpoint) {
                stickMovement = 1.0f;
            } else {
                stickMovement = rcCommand * rate;
            }
        } else {
            if (rcCommand <= -breakpoint) {
                stickMovement = -1.0f;
            } else {
                stickMovement = rcCommand * rate;
            }
        }
    }

    // Apply expo curve for more control near the center
    float angleRate = 200.0f * rcRate * stickMovement;
    angleRate = angleRate * (1.0f + stickMovement * expo * (stickMovement * stickMovement - 1.0f));

    return angleRate;
}

void setup() {
    Serial.begin(115200);
    Wire.begin();

    // Initialize the MPU9250 sensor
    if (!mpu.setup(0x68)) {  // 0x68 is the I2C address
        Serial.println("MPU9250 initialization failed!");
        while (1);
    }
    Serial.println("MPU9250 initialized successfully");

    // Initialize HID Mouse
    Mouse.begin();
    Serial.println("USB Mouse ready");

    // Calibrate gyro baselines
    calibrateBaseline();
}

void loop() {
    // Update sensor data
    if (mpu.update()) {
        // Get gyroscope data (radians per second)
        float gyroX = mpu.getGyroX();  // Gyro X affects vertical movement (Y-axis)
        float gyroY = mpu.getGyroY();  // Gyro Y affects horizontal movement (X-axis)

        // Calculate gyro deltas from the baseline
        float deltaX = gyroY - baselineY;  // Mapping Y-axis to X for mouse movement
        float deltaY = gyroX - baselineX;  // Mapping X-axis to Y for mouse movement

        // Normalize gyro input to -1 to 1 range (assuming max gyro reading of 2000 deg/s)
        float normalizedX = constrain(deltaX / 2000.0f, -1.0f, 1.0f);
        float normalizedY = constrain(deltaY / 2000.0f, -1.0f, 1.0f);

        // Apply Betaflight "Actual" rates
        float rateX = applyBetaflightActualRates(normalizedX, RC_RATE_X, RATE_X, EXPO_X);
        float rateY = applyBetaflightActualRates(normalizedY, RC_RATE_Y, RATE_Y, EXPO_Y);

        // Scale the rates to mouse movement
        float scaledDeltaX = rateX * MAX_DELTA / 1000.0f;
        float scaledDeltaY = rateY * MAX_DELTA / 1000.0f;

        // Apply smoothing for more controlled movement
        smoothedDeltaX = SMOOTHING_FACTOR * scaledDeltaX + (1 - SMOOTHING_FACTOR) * smoothedDeltaX;
        smoothedDeltaY = SMOOTHING_FACTOR * scaledDeltaY + (1 - SMOOTHING_FACTOR) * smoothedDeltaY;

        // Move the mouse only if the change is above the drift threshold
        if (fabsf(smoothedDeltaX) > DRIFT_THRESHOLD || fabsf(smoothedDeltaY) > DRIFT_THRESHOLD) {
            Mouse.move(-smoothedDeltaX, smoothedDeltaY);
        } else {
            // Reset smoothed values if below threshold to prevent accumulation
            smoothedDeltaX = 0;
            smoothedDeltaY = 0;
        }

        // Print gyro and mouse movement data for debugging
        Serial.print("Gyro: X=");
        Serial.print(gyroX, 2);
        Serial.print(", Y=");
        Serial.print(gyroY, 2);
        Serial.print(" | Mouse: dX=");
        Serial.print(smoothedDeltaX, 2);
        Serial.print(", dY=");
        Serial.println(smoothedDeltaY, 2);
    }

    delay(UPDATE_INTERVAL);
}

// Calibrate the baseline gyro values
void calibrateBaseline() {
    const int numSamples = 1000;
    float sumX = 0, sumY = 0;

    // Average gyro values over time to determine the baseline
    for (int i = 0; i < numSamples; i++) {
        if (mpu.update()) {
            sumX += mpu.getGyroX();
            sumY += mpu.getGyroY();
        }
        delay(1);
    }

    baselineX = sumX / numSamples;
    baselineY = sumY / numSamples;

    Serial.print("Baseline calibrated: X=");
    Serial.print(baselineX, 2);
    Serial.print(", Y=");
    Serial.println(baselineY, 2);
}
